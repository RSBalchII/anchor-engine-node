<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Ghost Engine (Headless)</title>
    <script type="module">
        import initCozo, { CozoDb } from './cozo_lib_wasm.js';

        const BRIDGE_URL = `ws://${window.location.host}/ws/chat`;
        let socket = null;
        let db = null;

        async function init() {
            reportLog("Initializing...");
            try {
                try {
                    await initCozo(); // Initialize WASM first
                    // Try persistent storage, fallback to memory
                    try {
                        db = await CozoDb.new_from_indexed_db("coda_memory_v2", "cozo_store", () => { });
                        reportLog("âœ… CozoDB (Persistent) Loaded [v2]");
                    } catch (e) {
                        reportLog("Persistence failed, using memory: " + e.message);
                        db = CozoDb.new();
                    }

                    await ensureSchema();
                } catch (e) {
                    console.error("[Ghost] Database Init Error: " + e.message);
                    // Continue to connect WS so we can report the error
                    setTimeout(() => reportError("Database Init Failed: " + e.message), 1000);
                }
                connectWebSocket();
            } catch (e) {
                console.error("[Ghost] Critical Init Error: " + e.message);
            }
        }

        // ... (reportLog logic stays same)

        async function ensureSchema() {
            const query = `
                :create memory {
                    id: String =>
                    timestamp: Int,
                    content: String,
                    source: String,
                    type: String
                } if not exists;
                
                ::fts create memory:content_fts { 
                    extractor: content, 
                    tokenizer: Simple, 
                    filters: [Lowercase] 
                } if not exists;
            `;
            const res = await runQuery(query);
            if (!res.ok) {
                reportLog("âŒ Schema Creation Failed: " + JSON.stringify(res));
                throw new Error("Schema Creation Failed: " + res.error);
            } else {
                reportLog("âœ… Schema verified");
            }
        }

        async function runQuery(datalog, params = {}) {
            try {
                const res = await db.run(datalog, JSON.stringify(params));
                const json = JSON.parse(res);
                return json;
            } catch (e) {
                return { ok: false, error: e.message };
            }
        }

        function connectWebSocket() {
            socket = new WebSocket(BRIDGE_URL);

            socket.onopen = async () => {
                console.log("[Ghost] ðŸŸ¢ Bridge Connected");
                socket.send(JSON.stringify({ type: "engine_ready" }));

                // DEBUG: Check DB stats
                try {
                    const countRes = await runQuery('?[count(id)] := *memory{id}');
                    reportLog(`ðŸ“Š Database Stats: ${JSON.stringify(countRes)}`);

                    if (countRes.rows && countRes.rows[0]) {
                        reportLog(`ðŸ“š Total Documents: ${countRes.rows[0][0]}`);
                    } else {
                        reportLog("âš ï¸ Database appears empty!");
                    }
                } catch (e) {
                    reportLog("Error checking stats: " + e.message);
                }
            };

            socket.onmessage = async (e) => {
                const msg = JSON.parse(e.data);
                if (msg.type === "ingest" || msg.type === "memory_ingest") await handleIngest(msg);
                if (msg.type === "direct_search_request") await handleSearch(msg);
            };

            socket.onclose = () => setTimeout(connectWebSocket, 3000);
        }

        async function handleIngest(msg) {
            console.log(`[Ghost] ðŸ“¥ Ingesting: ${msg.filename}`);
            const id = `doc_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
            const ts = Date.now();
            const query = `?[id, timestamp, content, source, type] <- $data :put memory { id, timestamp, content, source, type }`;
            await runQuery(query, { data: [[id, ts, msg.content, msg.filename, msg.filetype || "text"]] });

            // Acknowledge completion to Bridge
            if (msg.id) {
                socket.send(JSON.stringify({
                    id: msg.id,
                    type: "ingest_complete",
                    status: "success",
                    doc_id: id
                }));
            }
        }

        async function handleSearch(msg) {
            console.log(`[Ghost] ðŸ” Searching: "${msg.query}"`);
            const limit = msg.limit || 10;
            let results = [];

            // 1. Try Filename Match (Source)
            try {
                const nameQuery = `?[source, content] := *memory{source, content}, regex_matches($q, source) :limit $limit`;
                const nameRes = await runQuery(nameQuery, { q: msg.query, limit });
                if (nameRes.rows) results.push(...nameRes.rows);
            } catch (e) { }

            // 2. Try FTS (Content)
            try {
                const ftsQuery = `?[source, content] := *memory{source, content}, ~memory:content_fts{content | query: $q} :limit $limit`;
                const ftsRes = await runQuery(ftsQuery, { q: msg.query, limit });
                if (ftsRes.rows) {
                    // Dedup: only add if not already in results
                    for (const row of ftsRes.rows) {
                        if (!results.some(r => r[0] === row[0])) results.push(row);
                    }
                }
            } catch (e) { }

            // 3. Fallback Regex (Content) - Only if few results
            if (results.length < 5) {
                const scanQuery = `?[source, content] := *memory{source, content}, regex_matches($q, content) :limit $limit`;
                const scanRes = await runQuery(scanQuery, { q: msg.query, limit });
                if (scanRes.rows) {
                    for (const row of scanRes.rows) {
                        if (!results.some(r => r[0] === row[0])) results.push(row);
                    }
                }
            }

            // 3. Format Markdown
            let output = "";
            let charCount = 0;
            const maxChars = msg.max_chars || 10000;

            for (const [source, content] of results) {
                if (charCount + content.length > maxChars) break;
                output += `### Source: ${source}\n${content}\n\n`;
                charCount += content.length;
            }

            if (!output) output = "No relevant context found.";

            socket.send(JSON.stringify({
                type: "direct_search_result",
                id: msg.id,
                result: output
            }));
        }

        init();
    </script>
</head>

<body></body>

</html>