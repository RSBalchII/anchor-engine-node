<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Root Memory Builder</title>
    <style>
        :root {
            --bg: #1e1e1e;
            --text: #e0e0e0;
            --accent: #00ff88;
            --danger: #ff4444;
            --warn: #ffc107;
            --surface: #252526;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }

        h1 {
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
            color: var(--accent);
            font-weight: 300;
            letter-spacing: 1px;
        }

        .drop-zone {
            border: 2px dashed #444;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            border-radius: 8px;
            transition: all 0.3s;
            cursor: pointer;
            background: #111;
        }

        .drop-zone:hover {
            border-color: var(--accent);
            background: var(--surface);
        }

        .log-area {
            background: #111;
            border: 1px solid #333;
            padding: 10px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 0.85rem;
            color: #aaa;
            border-radius: 4px;
        }

        button {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-right: 10px;
            transition: all 0.2s;
        }

        button:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        button:disabled {
            background: #222;
            color: #555;
            border-color: #333;
            cursor: not-allowed;
        }

        button.primary {
            background: var(--accent);
            color: #000;
            border: none;
        }

        button.primary:hover {
            background: #00cc6a;
        }

        button.danger {
            background: var(--danger);
            border-color: var(--danger);
        }

        button.danger:hover {
            background: #cc0000;
        }

        .stat-box {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat {
            background: var(--surface);
            padding: 15px;
            border-radius: 6px;
            flex: 1;
            text-align: center;
            border: 1px solid #333;
        }

        .stat-val {
            font-size: 1.5rem;
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #888;
            text-transform: uppercase;
        }

        textarea {
            width: 100%;
            height: 60px;
            background: #111;
            color: #e0e0e0;
            border: 1px solid #555;
            padding: 10px;
            border-radius: 4px;
            resize: vertical;
            margin-bottom: 10px;
            font-family: inherit;
        }

        textarea:focus {
            outline: none;
            border-color: var(--accent);
        }
    </style>
</head>

<body>

    <h1>üå± Root Memory Builder</h1>
    <p>Ingest session logs into your local Root Graph.</p>

    <div class="stat-box">
        <div class="stat">
            <span id="db-status" class="stat-val" style="color: #ff6b6b">Offline</span>
            <span class="stat-label">Status</span>
        </div>
        <div class="stat">
            <span id="mem-count" class="stat-val">0</span>
            <span class="stat-label">Memories</span>
        </div>
        <div class="stat">
            <span id="vec-status" class="stat-val">Loading...</span>
            <span class="stat-label">Embedder</span>
        </div>
    </div>

    <div class="drop-zone" id="drop-zone">
        Drag & Drop <code>combined_memory.json</code>, logs, or text files here<br>
        <small style="color: #666">JSON, MD, TXT, PY, JS, HTML</small>
    </div>
    <input type="file" id="file-input" multiple style="display:none">

    <!-- Quick Add Section -->
    <div style="margin: 20px 0; padding: 20px; border: 1px solid #333; background: var(--surface); border-radius: 8px;">
        <h3 style="margin-top: 0; font-weight: 300;">üìù Quick Add</h3>
        <textarea id="quick-mem-content" placeholder="Type a memory here (e.g. 'Project X password is...')"></textarea>
        <div style="text-align: right;">
            <button id="quick-add-btn" class="primary">Add to Graph</button>
        </div>
    </div>

    <div style="margin-bottom: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
        <button id="auto-import-btn" disabled title="Import from ./cozo_import_memory.json">Auto-Import</button>
        <button id="export-db-btn" disabled>Export JSON</button>
        <button id="query-btn" disabled>Test Query</button>
        <div style="flex-grow: 1"></div>
        <button id="reset-btn" class="danger" disabled>Nuke Database</button>
    </div>

    <div class="log-area" id="logs"></div>

    <script type="module">
        import { AnchorLogger, initCozo, createStore } from './modules/anchor.js';
        import { loadAllFromIndexedDb, closeDatabase, clearIndexedDbStore, flushPendingWrites } from './indexeddb.js';
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.16.0';

        env.allowLocalModels = false;

        // --- 0. KERNEL SETUP ---
        const logger = new SovereignLogger('Root-Builder');

        // Wrap logger to output to DOM as well
        const originalInfo = logger.info.bind(logger);
        logger.info = (msg) => { originalInfo(msg); appendLog(msg, 'info'); };

        const originalWarn = logger.warn.bind(logger);
        logger.warn = (msg) => { originalWarn(msg); appendLog(msg, 'warn'); };

        const originalError = logger.error.bind(logger);
        logger.error = (msg) => { originalError(msg); appendLog(msg, 'error'); };

        const originalSuccess = logger.success.bind(logger);
        logger.success = (msg) => { originalSuccess(msg); appendLog(msg, 'success'); };

        function appendLog(msg, type) {
            const logs = document.getElementById('logs');
            const line = document.createElement('div');
            const time = new Date().toLocaleTimeString();
            line.textContent = `[${time}] ${msg}`;
            if (type === 'error') line.style.color = '#ff6b6b';
            if (type === 'success') line.style.color = '#00ff88';
            if (type === 'warn') line.style.color = '#ffc107';
            logs.appendChild(line);
            logs.scrollTop = logs.scrollHeight;
        }

        const { state, subscribe } = createStore({
            dbStatus: 'Offline',
            dbColor: '#ff6b6b',
            memCount: 0,
            embedderStatus: 'Loading...',
            embedderColor: '#ffc107',
            isReady: false
        });

        // UI Bindings
        subscribe((prop, val) => {
            if (prop === 'dbStatus') {
                const el = document.getElementById('db-status');
                el.innerText = val;
                el.style.color = state.dbColor;
            }
            if (prop === 'memCount') document.getElementById('mem-count').innerText = val;
            if (prop === 'embedderStatus') {
                const el = document.getElementById('vec-status');
                el.innerText = val;
                el.style.color = state.embedderColor;
            }
            if (prop === 'isReady' && val === true) {
                document.getElementById('auto-import-btn').disabled = false;
                document.getElementById('export-db-btn').disabled = false;
                document.getElementById('reset-btn').disabled = false;
                document.getElementById('query-btn').disabled = false;
            }
        });

        let db;
        let embedder;
        let CozoDbClass;

        // --- 1. INITIALIZATION ---
        async function init() {
            try {
                logger.info("Initializing Root Kernel...");

                // Load Cozo WASM via Kernel
                CozoDbClass = await initCozo('./cozo_lib_wasm_bg.wasm');

                // Probe IndexedDB (Recovery Logic)
                try {
                    const [keys, items] = await loadAllFromIndexedDb('coda_memory', 'cozo_store', () => { });
                    logger.info(`Storage Probe: Found ${keys.length} items in persistence layer.`);
                    closeDatabase(); // Important: Release lock

                    // Try Persistent Load
                    try {
                        const dbPromise = CozoDbClass.new_from_indexed_db('coda_memory', 'cozo_store', () => { });
                        // Timeout protection
                        const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('DB Load Timeout')), 5000));
                        db = await Promise.race([dbPromise, timeoutPromise]);

                        state.dbStatus = "Active (Persistent)";
                        state.dbColor = "#00ff88";
                        logger.success("Root Graph Online (Persistent).");
                    } catch (e) {
                        logger.warn(`Persistence load failed: ${e.message}. Clearing corruption...`);
                        await clearIndexedDbStore('coda_memory', 'cozo_store');
                        // Fallback to In-Memory
                        db = CozoDbClass.new();
                        state.dbStatus = "Active (Memory-Only)";
                        state.dbColor = "#ffc107";
                        logger.warn("Fallback to In-Memory DB. Data will not be saved.");
                    }

                } catch (e) {
                    logger.warn("Storage probe failed. Creating fresh in-memory DB.");
                    db = CozoDbClass.new();
                    state.dbStatus = "Active (Memory-Only)";
                    state.dbColor = "#ffc107";
                }

                // Global Exposure for Debugging
                window.db = db;
                window.runQuery = safeRun;

                // Load Embedder
                pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2').then(pipe => {
                    embedder = pipe;
                    state.embedderStatus = "Ready";
                    state.embedderColor = "#00ff88";
                    logger.success("Neural Embedder Loaded.");
                }).catch(e => {
                    state.embedderStatus = "Error";
                    state.embedderColor = "#ff4444";
                    logger.error(`Embedder failed: ${e.message}`);
                });

                // Schema Sync
                await ensureSchema();
                await updateStats();
                state.isReady = true;

            } catch (e) {
                logger.error(`CRITICAL FAILURE: ${e.message}`);
            }
        }

        async function safeRun(query, params = "{}") {
            if (!db) throw new Error("DB offline");
            const res = await db.run(query, params);
            let parsed = res;
            if (typeof res === 'string') {
                try { parsed = JSON.parse(res); } catch (e) { }
            }
            if (parsed && parsed.ok === false) throw new Error(parsed.message);
            return parsed;
        }

        async function ensureSchema() {
            try {
                // 1. Check if table exists
                await safeRun("?[id] := *memory{id} :limit 1", "{}");

                // 2. Migration: Try to add new columns if they don't exist
                // (CozoDB ignores 'add' if column exists or throws specific error, we catch to be safe)
                try { await safeRun("::alter memory add mime_type: String?", "{}"); } catch (e) { }
                try { await safeRun("::alter memory add blob_ref: String?", "{}"); } catch (e) { }

            } catch (e) {
                logger.warn("Schema missing. Creating Root Graph schema...");
                await safeRun(`
                    :create memory {
                        id: String =>
                        timestamp: Int,
                        role: String,
                        content: String,
                        source: String,
                        embedding: <F32; 384>,
                        mime_type: String?,
                        blob_ref: String?
                    }
                `, "{}");
                logger.success("Schema Created.");
            }
        }

        async function updateStats() {
            try {
                const res = await safeRun(`?[count(id)] := *memory{id}`, "{}");
                if (res.rows && res.rows.length) state.memCount = res.rows[0][0];
            } catch (e) { }
        }

        // --- 2. INGESTION LOGIC ---
        const SOV_BATCH_SIZE = 50;

        async function handleFiles(files) {
            if (!embedder || !db) return logger.error("System not ready.");
            for (const file of files) {
                logger.info(`Reading ${file.name} (${file.type || 'unknown'})...`);
                try {
                    let records = [];

                    // Binary Handling (Images/Audio)
                    if (file.type.startsWith('image/') || file.type.startsWith('audio/')) {
                        records = [{
                            role: 'user',
                            source: file.name,
                            timestamp: file.lastModified,
                            content: `[BINARY_REF] ${file.name}`, // Placeholder for text search
                            mime_type: file.type,
                            blob_ref: file.name
                        }];
                    }
                    // Text Handling
                    else {
                        const text = await file.text();

                        if (file.name.endsWith('.json')) {
                            const json = JSON.parse(text);
                            if (Array.isArray(json)) records = json;
                            else if (json.conversations) records = json.conversations;
                            else if (json.relations) {
                                // Extract rows logic simplified
                                const mem = json.relations.find(r => r.name === 'memory') || json.relations[0];
                                if (mem) {
                                    const hdr = mem.headers || ['id', 'timestamp', 'role', 'content', 'source', 'embedding'];
                                    records = (mem.rows || []).map(r => {
                                        const obj = {};
                                        hdr.forEach((h, i) => obj[h] = r[i]);
                                        return obj;
                                    });
                                }
                            }
                        } else {
                            // Text file
                            records = [{
                                role: 'system',
                                source: file.name,
                                timestamp: file.lastModified,
                                content: text
                            }];
                        }
                    }

                    await processRecords(records, file.name);
                } catch (e) {
                    logger.error(`Failed ${file.name}: ${e.message}`);
                }
            }
            await updateStats();
        }

        async function processRecords(records, sourceName) {
            let batch = [];
            for (const rec of records) {
                let content = rec.content || rec.message || "";
                if (!content) continue;
                if (content.length > 20000) content = content.substring(0, 20000) + "...[TRUNCATED]";

                let embedding = rec.embedding || [];
                if (!embedding.length) {
                    try {
                        const out = await embedder(content, { pooling: 'mean', normalize: true });
                        embedding = Array.from(out.data);
                    } catch (e) {
                        logger.warn(`Embedding failed for item in ${sourceName}, using zero vector.`);
                        embedding = new Array(384).fill(0.0);
                    }
                }

                // Hardened Timestamp Logic
                let ts = rec.timestamp ? new Date(rec.timestamp).getTime() : Date.now();
                if (isNaN(ts)) ts = Date.now();

                const id = `${ts}-${Math.random().toString(36).substr(2, 9)}`;
                const mime = rec.mime_type || null;
                const ref = rec.blob_ref || null;

                batch.push([id, ts, rec.role || 'unknown', content, rec.source || sourceName, embedding, mime, ref]);

                if (batch.length >= SOV_BATCH_SIZE) {
                    await insertBatch(batch);
                    batch = [];
                }
            }
            if (batch.length) await insertBatch(batch);
            try { await flushPendingWrites(); } catch (e) { }
            logger.success(`Imported ${records.length} items from ${sourceName}`);
        }

        async function insertBatch(rows) {
            // Strict Schema Mapping: Variables must match Schema column names for :put
            const q = `
                ?[id, timestamp, role, content, source, embedding, mime_type, blob_ref] <- $data
                :put memory { id, timestamp, role, content, source, embedding, mime_type, blob_ref }
            `;
            
            try {
                await safeRun(q, JSON.stringify({ data: rows }));
            } catch (e) {
                logger.error(`Batch Insert Failed: ${e.message}`);
                
                // Fallback for Legacy Schema (6 columns)
                // We must bind all 8 items from the input array, but only use the first 6
                if (e.message.includes("column") || e.message.includes("arity")) {
                    logger.warn("Retrying with legacy schema (ignoring binary fields)...");
                    const legacyQ = `
                        ?[id, timestamp, role, content, source, embedding, _mime, _ref] <- $data
                        :put memory { id, timestamp, role, content, source, embedding }
                    `;
                    await safeRun(legacyQ, JSON.stringify({ data: rows }));
                } else {
                    throw e;
                }
            }
        }

        // --- 3. EVENT LISTENERS ---
        document.getElementById('drop-zone').addEventListener('click', () => document.getElementById('file-input').click());
        document.getElementById('file-input').addEventListener('change', (e) => handleFiles(e.target.files));

        document.getElementById('drop-zone').addEventListener('dragover', (e) => { e.preventDefault(); e.target.style.borderColor = '#00ff88'; });
        document.getElementById('drop-zone').addEventListener('drop', (e) => { e.preventDefault(); e.target.style.borderColor = '#444'; handleFiles(e.dataTransfer.files); });

        document.getElementById('quick-add-btn').addEventListener('click', async () => {
            const val = document.getElementById('quick-mem-content').value.trim();
            if (!val) return;
            await processRecords([{ role: 'manual', content: val, source: 'user_input' }], 'QuickAdd');
            document.getElementById('quick-mem-content').value = "";
            await updateStats();
        });

        document.getElementById('reset-btn').addEventListener('click', async () => {
            if (confirm("NUKE DATABASE? This destroys all data.")) {
                await clearIndexedDbStore('coda_memory', 'cozo_store');
                location.reload();
            }
        });

        document.getElementById('query-btn').addEventListener('click', async () => {
            try {
                const res = await safeRun("?[ts, content] := *memory{timestamp: ts, content} :sort -ts :limit 5");
                if (res.rows) logger.info("Recent:\n" + res.rows.map(r => `${new Date(r[0]).toLocaleTimeString()}: ${r[1].substring(0, 50)}...`).join('\n'));
                else logger.warn("No rows returned.");
            } catch (e) { logger.error(e.message); }
        });

        document.getElementById('auto-import-btn').addEventListener('click', async () => {
            try {
                const res = await fetch('./cozo_import_memory.json');
                const json = await res.json();
                let recs = Array.isArray(json) ? json : (json.conversations || []);
                if (recs.length) await processRecords(recs, 'auto-import');
                else logger.warn("No records found in auto-import file.");
            } catch (e) { logger.error(e.message); }
        });

        document.getElementById('export-db-btn').addEventListener('click', async () => {
            try {
                logger.info("Exporting Root Memory...");
                // Export the 'memory' relation including vectors
                const jsonStr = await db.export_relations(JSON.stringify({relations: ["memory"]}));
                
                // Create Blob and Download
                const blob = new Blob([jsonStr], {type: "application/json"});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `root_coda_memory_dump_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                logger.success("Export Complete. You can now drag this file into another Root Coda instance.");
            } catch (e) {
                logger.error("Export Failed: " + e.message);
            }
        });

        init();
    </script>
</body>

</html>