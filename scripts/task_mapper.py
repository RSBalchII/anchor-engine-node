#!/usr/bin/env python3
"""
Task Mapping Verification for ECE Project

This script verifies that all tasks defined in the specification
are properly mapped to implementation files.
"""

import os
import sys
import re
import json
from pathlib import Path
from typing import Dict, List, Tuple
import argparse

# Add project root to Python path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

class TaskMapper:
    """Maps specification tasks to implementation files."""
    
    def __init__(self, specs_dir: str = "specs", src_dir: str = "ece"):
        self.specs_dir = Path(specs_dir)
        self.src_dir = Path(src_dir)
        self.task_map = {}
        self.implementation_files = []
        
    def parse_tasks_file(self) -> List[Dict[str, str]]:
        """Parse the tasks.md file to extract all tasks."""
        tasks_file = self.specs_dir / "tasks.md"
        if not tasks_file.exists():
            print(f"âŒ Tasks file not found: {tasks_file}")
            return []
            
        with open(tasks_file, 'r') as f:
            content = f.read()
            
        # Extract tasks using regex
        # Pattern for tasks like: - [x] **Task 1.1:** Description
        task_pattern = r'- \[\s*[x ]\s*\]\s*\*\*Task ([\d\.]+):\s*(.*?)\*\*'
        tasks = re.findall(task_pattern, content)
        
        task_list = []
        for task_num, description in tasks:
            task_list.append({
                "id": f"TASK-{task_num.replace('.', '-')}",
                "number": task_num,
                "description": description.strip(),
                "completed": "[x]" in content.split(f"**Task {task_num}:")[0].split("- [")[-1]
            })
            
        print(f"ðŸ“‹ Parsed {len(task_list)} tasks from specification")
        return task_list
    
    def find_implementation_files(self) -> List[str]:
        """Find all Python implementation files."""
        py_files = list(self.src_dir.rglob("*.py"))
        impl_files = [str(f.relative_to(self.src_dir)) for f in py_files]
        print(f"ðŸ“ Found {len(impl_files)} Python files in implementation")
        return impl_files
    
    def map_tasks_to_files(self, tasks: List[Dict]) -> Dict[str, List[str]]:
        """Map tasks to relevant implementation files based on keywords."""
        task_file_map = {}
        
        # Common task-to-component mappings
        component_mappings = {
            "Archivist": ["agents/tier3/archivist/"],
            "Distiller": ["agents/tier3/distiller/"],
            "Injector": ["agents/tier3/injector/"],
            "QLearning": ["agents/tier3/qlearning/"],
            "Orchestrator": ["agents/tier1/"],
            "Thinker": ["agents/tier2/"],
            "Context Cache": ["components/context_cache/"],
            "POML": ["poml/"],
            "API": ["main.py", "app.py"],
            "Docker": ["docker-compose.yml", "Dockerfile"],
            "Redis": ["components/context_cache/"],
            "Neo4j": ["agents/tier3/injector/", "agents/tier3/qlearning/"]
        }
        
        for task in tasks:
            task_id = task["id"]
            description = task["description"].lower()
            mapped_files = []
            
            # Map based on component keywords
            for component, paths in component_mappings.items():
                if component.lower() in description:
                    for path in paths:
                        # Find files that match this path
                        for impl_file in self.implementation_files:
                            if path in impl_file:
                                mapped_files.append(impl_file)
                                
            # If no specific mapping found, map to general files
            if not mapped_files:
                mapped_files = ["README.md"]  # Default
                
            task_file_map[task_id] = list(set(mapped_files))  # Remove duplicates
            
        return task_file_map
    
    def generate_task_map_file(self, task_file_map: Dict[str, List[str]]) -> str:
        """Generate a YAML task map file."""
        yaml_content = "# ECE Task Mapping\n"
        yaml_content += "# Automatically generated by task_mapper.py\n\n"
        
        for task_id, files in task_file_map.items():
            yaml_content += f"{task_id}:\n"
            yaml_content += "  files:\n"
            for file_path in files:
                yaml_content += f"    - {file_path}\n"
            yaml_content += "n"
            
        return yaml_content
    
    def verify_task_coverage(self, tasks: List[Dict], task_file_map: Dict[str, List[str]]) -> Dict[str, int]:
        """Verify task coverage statistics."""
        completed_tasks = [t for t in tasks if t["completed"]]
        mapped_tasks = [t for t in tasks if task_file_map.get(t["id"])]
        
        return {
            "total_tasks": len(tasks),
            "completed_tasks": len(completed_tasks),
            "mapped_tasks": len(mapped_tasks),
            "unmapped_tasks": len(tasks) - len(mapped_tasks),
            "coverage_percentage": round((len(mapped_tasks) / len(tasks)) * 100, 2) if tasks else 0
        }
    
    def run_mapping(self) -> bool:
        """Run the complete task mapping process."""
        print("ðŸ” Running Task Mapping Verification...")
        print("=" * 50)
        
        # Parse tasks
        tasks = self.parse_tasks_file()
        if not tasks:
            print("âŒ Failed to parse tasks")
            return False
            
        # Find implementation files
        self.implementation_files = self.find_implementation_files()
        
        # Map tasks to files
        task_file_map = self.map_tasks_to_files(tasks)
        
        # Verify coverage
        coverage_stats = self.verify_task_coverage(tasks, task_file_map)
        
        # Display results
        print(f"nðŸ“Š Task Mapping Results:")
        print(f"   Total Tasks: {coverage_stats['total_tasks']}")
        print(f"   Completed Tasks: {coverage_stats['completed_tasks']}")
        print(f"   Mapped Tasks: {coverage_stats['mapped_tasks']}")
        print(f"   Unmapped Tasks: {coverage_stats['unmapped_tasks']}")
        print(f"   Coverage: {coverage_stats['coverage_percentage']}%")
        
        # Show sample mappings
        print(f"nðŸ“‹ Sample Task Mappings:")
        sample_count = 0
        for task_id, files in list(task_file_map.items())[:5]:
            print(f"   {task_id}: {files}")
            sample_count += 1
            if sample_count >= 5:
                break
                
        if len(task_file_map) > 5:
            print(f"   ... and {len(task_file_map) - 5} more mappings")
            
        # Generate task map file
        yaml_content = self.generate_task_map_file(task_file_map)
        task_map_file = self.specs_dir / "task_map.yml"
        with open(task_map_file, 'w') as f:
            f.write(yaml_content)
        print(f"nðŸ“„ Generated task map file: {task_map_file}")
        
        # Check for unmapped tasks
        unmapped = []
        for task in tasks:
            if not task_file_map.get(task["id"]):
                unmapped.append(task["id"])
                
        if unmapped:
            print(f"nâš ï¸ Unmapped Tasks:")
            for task_id in unmapped[:10]:  # Show first 10
                print(f"   â€¢ {task_id}")
            if len(unmapped) > 10:
                print(f"   ... and {len(unmapped) - 10} more")
                
        return True

def main():
    parser = argparse.ArgumentParser(description="Task Mapper for ECE")
    parser.add_argument("--specs-dir", default="specs", help="Specifications directory")
    parser.add_argument("--src-dir", default="ece", help="Source code directory")
    
    args = parser.parse_args()
    
    mapper = TaskMapper(
        specs_dir=args.specs_dir,
        src_dir=args.src_dir
    )
    
    success = mapper.run_mapping()
    
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()